{
  "title": "Containers and Iterators",
  "mk_intructions": "\n<link rel=\"icon\" type=\"image/png\" href=\"/eecs280-async-lectures/favicon-96x96.png\" sizes=\"96x96\" />\n<link rel=\"icon\" type=\"image/svg+xml\" href=\"/eecs280-async-lectures/favicon.svg\" />\n<link rel=\"shortcut icon\" href=\"/eecs280-async-lectures/favicon.ico\" />\n<link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/eecs280-async-lectures/apple-touch-icon.png\" />\n<meta name=\"apple-mobile-web-app-title\" content=\"Async Lecs\" />\n<link rel=\"manifest\" href=\"/eecs280-async-lectures/site.webmanifest\" />\n<div markdown=1 class=\"alert alert-success\">\n  I didn't get this one published as early as usual, so I've extended the participation deadline by 24 hours to give a little extra flexibility.\n</div>\n<div markdown=1 class=\"alert alert-info\">\n  This lecture covers a broad overview of **containers** as well as the fundamental approaches to implementing their underlying **data structures**.\n  \n  Containers serve a variety of purposes. Here's a few containers from the C++ standard library as examples:\n  \n  - A `std::vector<double>` could store datapoints for statistical analysis\n  - A `std::set<string>` could represent uniqnames of students registered for a course\n  - A `std::map<string, double>` could allow us to look up the price of an item on a menu by providing its name\n\n  <!-- force end of list -->\n\n  We'll also take a look at the way the standard library uses **iterators** as the abstraction for locating and traversing through elements.\n  \n  <div style=\"position: absolute; bottom: 5px; right: 10px; font-weight: bold;\">Updated Winter 2025</div>\n</div>\n<style>\n  .lec-video {\n    width: 80%;\n    aspect-ratio: 16/9;\n  }\n\n  iframe.lobster-iframe {\n    border: none;\n    width: 80%;\n    height: 450px;\n    margin-left: auto;\n    margin-right: auto;\n  }\n\n</style>",
  "mk_questions_message": "\n<div style=\"text-align: left\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-house-fill\" viewBox=\"0 0 16 16\">\n  <path d=\"M8.707 1.5a1 1 0 0 0-1.414 0L.646 8.146a.5.5 0 0 0 .708.708L8 2.207l6.646 6.647a.5.5 0 0 0 .708-.708L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293z\"/>\n  <path d=\"m8 3.293 6 6V13.5a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 13.5V9.293z\"/>\n</svg>\n<a style=\"vertical-align: middle;\" href=\"/eecs280-async-lectures\">\n  Table of Contents\n</a>\n<br />\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-file-earmark-slides\" viewBox=\"0 0 16 16\">\n  <path d=\"M5 6a.5.5 0 0 0-.496.438l-.5 4A.5.5 0 0 0 4.5 11h3v2.016c-.863.055-1.5.251-1.5.484 0 .276.895.5 2 .5s2-.224 2-.5c0-.233-.637-.429-1.5-.484V11h3a.5.5 0 0 0 .496-.562l-.5-4A.5.5 0 0 0 11 6H5zm2 3.78V7.22c0-.096.106-.156.19-.106l2.13 1.279a.125.125 0 0 1 0 .214l-2.13 1.28A.125.125 0 0 1 7 9.778z\"/>\n  <path d=\"M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z\"/>\n</svg>\n<a style=\"vertical-align: middle;\" target=\"_blank\" href=\"https://drive.google.com/drive/folders/1wdIk41500J4SILWprRAxB1-c4m8A2Wux\">\n  Slides (Powerpoint, PDF)\n</a>\n<br />\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-github\" viewBox=\"0 0 16 16\">\n<path d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z\"/>\n</svg>\n<a style=\"vertical-align: middle;\" target=\"_blank\" href=\"https://github.com/jamesjuett/eecs280-async-lectures\">\n  Report issues or make suggestions\n</a>\n</div>\n",
  "mk_bottom_message": "You've reached the end of this lecture! Your work on any exercises will be saved if you re-open this page in the same web browser.\n\n**Participation Credit**  \nMake sure to sign in to the page, complete each of the exercises, and **double check** the participation indicator at the top left of this page to ensure you've earned credit.",
  "mk_download_message": "Export your exercise answers to use with another computer or browser.",
  "mk_saver_message": "Your work on exercises is **automatically** saved in your web browser's local storage. That means you don't need to do anything to save your work as long as:\n- You use the same computer\n- You use the same web browser\n- You don't use incognito or private browsing (which disables local storage)\n\nTo transfer answers between computers or browsers, use the import/export options below.",
  "assets_dir": "/home/jjuett/eecs280/async-lectures/lectures/lecture13_5/assets",
  "allow_clientside_content": true,
  "sections": [
    {
      "section_id": "section_11_1",
      "title": "Introduction to Standard Library Containers",
      "mk_description": "        \n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/OsOmWAPXySA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": []
    },
    {
      "section_id": "section_11_2",
      "title": "Sequential Containers with Contiguous Allocation",
      "mk_description": "\nThere are two fundamental approaches to data representation for containers. The first of these is to use a **contiguous allocation** (i.e. elements are stored in an underlying array). `std::array` and `std::vector` are sequential containers from the C++ standard library that use this approach.\n\n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/0PV-zEA08z4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": [
        {
          "question_id": "lec_contiguous_allocation_containers",
          "points": 5,
          "mk_description": "Which of the following are true?",
          "response": {
            "kind": "multiple_choice",
            "choices": [
              "Both a `std::array` and a `std::vector` use a single, contiguous memory allocation to store their elements.",
              "The implementation of `std::array` contains a pointer to a separately allocated array.",
              "The implementation of `std::vector` must use separate variables to track its current size vs. the capacity of the underlying array.",
              "A `std::array` is dynamically sized - if more space for elements is needed, it can request an increase to the size of its underlying array.",
              "A `std::vector` is dynamically sized - if more space for elements are needed, it can request a completely new, larger array and change its internal pointer to use that one instead."
            ],
            "multiple": true,
            "sample_solution": [
              0,
              2,
              4
            ],
            "default_grader": {
              "grader_kind": "summation_multiple_choice",
              "rubric": [
                {
                  "points": 1,
                  "selected": true
                },
                {
                  "points": 1,
                  "selected": false
                },
                {
                  "points": 1,
                  "selected": true
                },
                {
                  "points": 1,
                  "selected": false
                },
                {
                  "points": 1,
                  "selected": true
                }
              ]
            }
          },
          "verifier": {
            "verifier_kind": "full_credit"
          }
        }
      ]
    },
    {
      "section_id": "section_11_3",
      "title": "Sequential Containers with Linked Structures",
      "mk_description": "\nThe second fundamental approach to data representation for containers is to use a **linked structure** (i.e. elements are stored in nodes that point to each other). `std::list` and `std::forward_list` are sequential containers from the C++ standard library that use this approach.\n\n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/9HrsiY_Hqyk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": [
        {
          "question_id": "lec_contiguous_vs_linked_time_complexity",
          "title": "Exercise: Time Complexity",
          "points": 7,
          "mk_description": "Determine the time complexity of each of the following operations on the given data structure. Using a worst-case analysis, determine whether each function has _O(1)_ constant time complexity or _O(n)_ linear time complexity.",
          "response": {
            "kind": "fill_in_the_blank",
            "content": "_BLANK__________________ Updating the value of the first element in a `std::array`.\n\n_BLANK__________________ Inserting a new element at the front (left) of a `std::vector`.\n\n_BLANK__________________ Inserting a new element at the back (right) of a `std::vector`.\n\n_BLANK__________________ Printing the value of the first element in a `std::list`.\n\n_BLANK__________________ Inserting a new element at the front (left) of a `std::list`.\n\n_BLANK__________________ Printing the element in the middle of a `std::list`.\n\n_BLANK__________________ Assuming you already have a pointer to some node within a `std::list`, inserting a new element right after that position.",
            "default_grader": {
              "grader_kind": "manual_regex_fill_in_the_blank",
              "rubric": [
                {
                  "blankIndex": 1,
                  "title": "Box 1",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has constant time complexity, since it's a case of indexing (i.e. at index 0) and indexing can be implemented with constant time complexity in array using pointer arithmetic.",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has constant time complexity, since it's a case of indexing (i.e. at index 0) and indexing can be implemented with constant time complexity in array using pointer arithmetic.",
                      "points": 0
                    }
                  ]
                },
                {
                  "blankIndex": 2,
                  "title": "Box 2",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has linear time complexity. A vector doesn't maintain any free space at the front, so inserting at the front requires shifting all existing elements to the right.",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has linear time complexity. A vector doesn't maintain any free space at the front, so inserting at the front requires shifting all existing elements to the right.",
                      "points": 0
                    }
                  ]
                },
                {
                  "blankIndex": 3,
                  "title": "Box 3",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has constant time complexity. A vector's free space is at the back, so we just need to access the next open space (using indexing, which is contant time), assign a new value there, and increase the current size variable.",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has constant time complexity. A vector's free space is at the back, so we just need to access the next open space (using indexing, which is contant time), assign a new value there, and increase the current size variable.",
                      "points": 0
                    }
                  ]
                },
                {
                  "blankIndex": 4,
                  "title": "Box 4",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has constant time complexity. The list has a pointer to the first node, which we can dereference to access the value of the first element.",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has constant time complexity. The list has a pointer to the first node, which we can dereference to access the value of the first element.",
                      "points": 0
                    }
                  ]
                },
                {
                  "blankIndex": 5,
                  "title": "Box 5",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has constant time complexity. Inserting a new first element in a linked list requires updating a few pointers, but doesn't require any more time for longer lists than shorter lists (i.e. we only need to update pointers at the front - we don't need to shift over all existing elements as we would in an array.)",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has constant time complexity. Inserting a new first element in a linked list requires updating a few pointers, but doesn't require any more time for longer lists than shorter lists (i.e. we only need to update pointers at the front - we don't need to shift over all existing elements as we would in an array.)",
                      "points": 0
                    }
                  ]
                },
                {
                  "blankIndex": 6,
                  "title": "Box 6",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has linear time complexity. Indexing into a linked list cannot be done efficiently, because it is not based on a contiguous memory allocation. Instead of using pointer arithmetic, we must traverse through a bunch of next pointers starting from the beginning of the list. In this case, the number of next pointers to get to the halfway point is linearly proportional to the size of the list.",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has linear time complexity. Indexing into a linked list cannot be done efficiently, because it is not based on a contiguous memory allocation. Instead of using pointer arithmetic, we must traverse through a bunch of next pointers starting from the beginning of the list. In this case, the number of next pointers to get to the halfway point is linearly proportional to the size of the list.",
                      "points": 0
                    }
                  ]
                },
                {
                  "blankIndex": 7,
                  "title": "Box 7",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "constant|O\\s*\\(\\s*1\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "Correct! The implementation has constant time complexity. If we already have a pointer to the node, we can insert a new element after it by updating a few pointers. We don't need to shift elements or change pointers for the rest of the list, either before or after the local point of insertion. (Note that if we did not start with the pointer to the node, this would be a linear operation in terms of how far into the list we need to go to insert.)",
                      "points": 1
                    },
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": "linear|O\\s*\\(\\s*n\\s*\\)",
                          "flags": "i"
                        }
                      },
                      "explanation": "The implementation has constant time complexity. If we already have a pointer to the node, we can insert a new element after it by updating a few pointers. We don't need to shift elements or change pointers for the rest of the list, either before or after the local point of insertion. (Note that if we did not start with the pointer to the node, this would be a linear operation in terms of how far into the list we need to go to insert.)",
                      "points": 0
                    }
                  ]
                }
              ]
            }
          },
          "verifier": {
            "verifier_kind": "full_credit"
          }
        },
        {
          "question_id": "lec_binary_search_contiguous_vs_linked",
          "title": "Exercise: Binary Search",
          "points": 1,
          "mk_description": "Recall the binary search algorithm, where we find a desired value in a _sorted_ array by:  \n  1. Finding the middle value current search range by indexing at the halfway point.  \n  2. Comparing the query value to the middle value.  \n  3. Repeating the process on the left or right half of the array, depending on the comparison result (or stop if we find the value).  \n\nUsing binary search, a lookup operation in a sorted array can be implemented in worst-case logarithmic time, _O(log n)_.\n\nHowever, this isn't the case for a sorted linked list! Why not? Explain why binary search is not a good fit for a linked list.",
          "response": {
            "kind": "fill_in_the_blank",
            "content": "[[BOX\n\n\n]]",
            "default_grader": {
              "grader_kind": "manual_regex_fill_in_the_blank",
              "rubric": [
                {
                  "blankIndex": 1,
                  "title": "Box 1",
                  "points": 1,
                  "description": "",
                  "patterns": [
                    {
                      "pattern": {
                        "examma_ray_serialized_regex": {
                          "source": ".{10,}",
                          "flags": "i"
                        }
                      },
                      "explanation": "This is just graded for completion. Check your answer against the sample solution",
                      "points": 1
                    }
                  ]
                }
              ]
            }
          },
          "verifier": {
            "verifier_kind": "full_credit"
          },
          "mk_postscript": "<hr />\n<details>\n  <summary>Sample solution...</summary>\n  \n  Binary search relies on efficient indexing to get the middle value in the array. In an array, this is possible via pointer arithmetic. But linked lists do not support efficient indexing! To take one step of the binary search algorithm, we'd need to traverse linearly through 50% of the list by following next pointers. This first step alone already puts us at linear time complexity (and rules out logarithmic time).\n  \n</details>"
        }
      ]
    },
    {
      "section_id": "section_11_4",
      "title": "Iterators and Traversal by Iterator",
      "mk_description": "\nThe C++ standard library uses the concept of an **iterator** to indicate the position of an element in a list and to facilitate traversal through elements.\n\n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/20lCBbM4CpI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />\n\nNote that traversal by iterator is analogous to traversal by pointer, which we've seen previously. (Although not all iterators are literally implemented as pointers.)",
      "questions": []
    },
    {
      "section_id": "section_11_5",
      "title": "The `auto` Keyword",
      "mk_description": "        \n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/B2MYNqlYB8Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": []
    },
    {
      "section_id": "section_11_6",
      "title": "Range-based `for` Loops",
      "mk_description": "        \n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/1xzy5yLeiVg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": []
    },
    {
      "section_id": "section_11_7",
      "title": "Iterator Interfaces",
      "mk_description": "\nIterator types are also used to specify the parameter or return types for many functions from the standard library.\n\n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/cOOMmqo90R0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": []
    },
    {
      "section_id": "section_11_8",
      "title": "Sets and Maps",
      "mk_description": "        \n<div style=\"text-align: center;\">\n  <iframe class=\"lec-video\" src=\"https://www.youtube.com/embed/gzHPz0BzP5U\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<br />",
      "questions": [
        {
          "question_id": "lec11_participation_freebie",
          "points": 1,
          "mk_description": "Select the item below for participation credit.",
          "response": {
            "kind": "multiple_choice",
            "choices": [
              "Select this for participation credit."
            ],
            "multiple": false,
            "sample_solution": [
              0
            ],
            "default_grader": {
              "grader_kind": "freebie",
              "points": 1,
              "allow_blanks": false
            }
          },
          "verifier": {
            "verifier_kind": "full_credit"
          }
        }
      ]
    }
  ],
  "exam_id": "w25_lec_14",
  "credentials_strategy": {
    "strategy": "google_local",
    "client_id": "444801118749-m2g9gl3gvvkh5ru959dmka0lsk94d9uq.apps.googleusercontent.com",
    "auth_endpoint": "https://examma-ray.eecs.umich.edu/public_api/participation/auth/",
    "message": "Sign in with your @umich.edu Google account to earn participation credit for completing embedded exercises."
  },
  "completion": {
    "threshold": 1,
    "tooltip": "",
    "endpoints": {
      "check": "https://examma-ray.eecs.umich.edu/public_api/participation/me/",
      "submit": "https://examma-ray.eecs.umich.edu/public_api/participation/me/"
    },
    "local_deadline": {
      "when": {
        "examma_ray_serialized_datetime": {
          "iso": "2025-02-27T23:59:59.000-05:00",
          "timezone": "America/Detroit"
        }
      },
      "grace_minutes": 5
    }
  }
}